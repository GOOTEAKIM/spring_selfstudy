# Spring 입문

## 6/29

### 커피잔 아이콘이 뜨면서 코드 실행이 안될 때?

- src 우클릭 - Make Directory as - Source Root
---
### 1. 프로젝트 환경 설정
---
#### 프로젝트 생성

- 스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성
- https://start.spring.io/

- 프로젝트 선택
  - Project: Gradle - Groovy Project
  - Spring Boot: 3.x.x
  - Language: Java
  - Packaging: Jar
  - Java: 17 또는 21

- Project Metadata
  - groupId: hello
  - artifactId: hello-spring

- Dependencies: Spring Web, Thymeleaf

- 스프링 부트 3.0 이상을 선택 할 것
---
#### Gradle 전체 설정

```gradle
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.3.1'
	id 'io.spring.dependency-management' version '1.1.5'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}


//java {
//	toolchain {
//		languageVersion = JavaLanguageVersion.of(22)
//	}
//}

repositories {
	mavenCentral()
}


dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'


	//test 롬복 사용
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'


	//Querydsl 추가
	implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
	annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"
	annotationProcessor "jakarta.annotation:jakarta.annotation-api"
	annotationProcessor "jakarta.persistence:jakarta.persistence-api"
}


tasks.named('test') {
	useJUnitPlatform()
}


clean {
	delete file('src/main/generated')
}

```

- 동작 확인
  - 기본 메인 클래스 실행
  - 스프링 부트 메인 실행 후 에러페이지로 간단하게 동작 확인( http://localhost:8080 )
---
#### View 환경설정

- src/main/resources/static/index.html

	```html
	<!DOCTYPE HTML>
	<html>
	<head>
	<title>Hello</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	</head>
	<body>
	Hello
	<a href="/hello">hello</a>
	</body>
	</html>
	```

- src/main/resources/templates/hello.html

	```html
	<!DOCTYPE HTML>
	<html xmlns:th="http://www.thymeleaf.org">
	<head>
			<title>Hello</title>
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	</head>
	<body>
	<p th:text="'안녕하세요. ' + ${data}" >안녕하세요. 손님</p>
	</body>
	</html>
	```

- src/main/main/java/hello.hello_spring/controller/HelloController

	```java
	package hello.hello_spring.controller;

	import org.springframework.stereotype.Controller;
	import org.springframework.ui.Model;
	import org.springframework.web.bind.annotation.GetMapping;

	@Controller
	public class HelloController {
			@GetMapping("hello")
			public String hello(Model model) {
					model.addAttribute("data", "hello!");
					return "hello";
			}
	}
	```

- 서버 실행
- http://localhost:8080/ 에서 글자가 나오는지 확인
- http://localhost:8080/hello 에서 글자가 나오는지 확인
- 설정 완료
---
### 빌드

- 빌드를 바로 하면 일단 JAVA_HOME 이 없다고 나온다

1. 윈도우에서 `시스템 변수 환경 편집` 실행.
2. 환경변수
3. 사용자 변수 새로 만들기
	- 변수 이름 : JAVA_HOME
	- 변수 값 : C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2024.1.2\jbr
4. 시스템 변수
	- 변수 새로 만들기
	- 변수 이름 : JAVA_HOME
	- 변수 값 : C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2024.
	
	- Path 편집
  	- 새로 만들기 : %JAVA_HOME%\bin
5. ./gradlew build 
6. 빌드 완료

---

## 7/1

### 2. 스프링 웹 개발 기초
---
#### Thymeleaf 가 작동 안할때

1. src/main/resources/application.properties 파일 확인

	```properties
	spring.thymeleaf.prefix=classpath:/templates/
	spring.thymeleaf.suffix=.html
	spring.thymeleaf.enabled=true
	```
2. 해당 코드 추가
3. 빌드 실행 (`./gradlew build`)
---

#### MVC 와 템플릿 엔진

- Controller

	```java
	@Controller
	public class HelloController {
			@GetMapping("hello-mvc")
			public String helloMvc(@RequestParam("name") String name, Model model) {
					model.addAttribute("name", name);
					return "hello-template";
			}
	}
	```

- View (resources/templates/hello-template.html)

```html
<html xmlns:th="http://www.thymeleaf.org">
<body>
<p th:text="'hello ' + ${name}">hello! empty</p>
</body>
</html>
```

- 실행
  - http://localhost:8080/hello-mvc?name=spring
---
### API

- @ResponseBody 문자 반환

	```java
	@Controller
	public class HelloController {

			@GetMapping("hello-string")
			@ResponseBody
			
			public String helloString(@RequestParam("name") String name) {
					return "hello " + name;
			}
	}
	```

	- `@ResponseBody` 를 사용하면 뷰 리졸버( viewResolver )를 사용하지 않음
	- 대신에 HTTP의 BODY에 문자 내용을 직접 반환

- 실행
  - http://localhost:8080/hello-string?name=spring

---

- @ResponseBody 객체 반환

```java
@Controller
public class HelloController {
		@GetMapping("hello-api")
		@ResponseBody

		public Hello helloApi(@RequestParam("name") String name) {
				Hello hello = new Hello();
				hello.setName(name);
				return hello;
		}

		static class Hello {
				private String name;
				public String getName() {
						return name;
				}

				public void setName(String name) {
						this.name = name;
				}
		}
}
```

- @ResponseBody 를 사용하고, 객체를 반환하면 객체가 `JSON`으로 변환됨

- 실행
	- http://localhost:8080/hello-api?name=spring
---
## 7/2

### 3. 회원 관리 예제
---
#### 회원 도메인과 리포지토리 만들기

	```java
	private Long id;
	private String name;
	```
	- alt + insert -> getter and setter

	- 테스트를 한번하면 깨끗하게 해줘야한다.
---
#### 회원 리포지토리 테스트 케이스 작성

- test/java/hello.hello_spring/폴더명

- 이 경로로 테스트 package 생성
- 클래스 이름 = 테스트 할 클래스 + Test
	- ex. MemoryMemberRepository + Test = `MemoryMemberRepositoryTest`
- public 으로 안만들어도 된다.
- 메서드 사용 전에 `@Test` 작성해줘야 한다.

- Assertions (org.junit.jupiter.api) 사용해야 한다.

- @AfterEach : 각 테스트가 종료될 때 마다 이 기능을 실행한다.
  - 테스트는 각각 독립적으로 실행되어야 한다. 
  - 테스트 순서에 의존관계가 있는 것은 좋은 테스트가 아니다.

- alt + enter -> replace static import : static import 추출
- shift + F6 : rename 
---

#### 회원 서비스 개발

- alt + insert : constructor 생성
- ctrl + alt + l : 코드 정리
- ctrl + alt + shift + t -> extract method
- ctrl + alt + v : 리턴을 해주는 대상 생성
- ctrl + alt + shift + t : 여러가지 단축어 보여줌
  - extract method : 새로운 메서드로 만들 수 있다

---

#### 회원 서비스 테스트

- ctrl + shift + T : 테스트 자동으로 생성
- 테스트 명은 한글로 바꿔도 상관없다.
---

## 7/3

### 4. 스프링 빈과 의존관계
---
#### 컴포넌트 스캔과 자동 의존관계 설정

- DI : 의존성 주입
  - 생성자에 `@Autowired` 가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아 넣어준다.


- 컴포넌트 스캔 원리
	- `@Component` 애노테이션이 있으면 스프링 빈으로 자동 등록된다.
	- `@Controller` 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문이다.

- @Autowired
  - 생성자에 @Autowired 를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입한다. 
	- 생성자가 1개만 있으면 @Autowired 는 생략할 수 있다.

- `@Component` 를 포함하는 다음 애노테이션도 스프링 빈으로 자동 등록된다.
  - @Controller
  - @Service
  - @Repository
---

## 7/3

### 5. 회원 관리 예제 - 웹 MVC 개발
---
#### 회원 웹 기능 - 홈 화면 추가

- 홈 컨트롤러 추가

	```java
	package hello.hellospring.controller;
	import org.springframework.stereotype.Controller;
	import org.springframework.web.bind.annotation.GetMapping;

	@Controller
	public class HomeController {

			@GetMapping("/")
			public String home() {
					return "home";
			}
	}
	```

	- GetMapping("주소") : (localhost:8000 + `주소`) 를 조회할때 사용, django == GET
---
#### 회원 웹 기능 - 등록

- 회원 등록 폼 컨트롤러

	```java
	@Controller
	public class MemberController {
			private final MemberService memberService;

			@Autowired
			public MemberController(MemberService memberService) {
					this.memberService = memberService;
			}

			@GetMapping(value = "/members/new")
			public String createForm() {
					return "members/createMemberForm";
			}
	}
	```
---
- 회원 등록 컨트롤러

  - 웹 등록 화면에서 데이터를 전달 받을 폼 객체

  	```java
  	public class MemberForm {
  			private String name;

  			public String getName() {
  					return name;
  			}

  			public void setName(String name) {
  					this.name = name;
  			}
  	}
  	```

  - 회원 컨트롤러에서 회원을 실제 등록하는 기능.

	```java
	@PostMapping(value = "/members/new")
	public String create(MemberForm form) {

			Member member = new Member();
			member.setName(form.getName());

			memberService.join(member);

			return "redirect:/";
	}
	```

  - PostMapping("주소") : (localhost:8000 + `주소`) 를 게시할때 사용, django == POST
---
#### 회원 웹 기능 - 조회

- 회원 컨트롤러에서 조회 기능

	```java
	@GetMapping(value = "/members")
	public String list(Model model) {

			List<Member> members = memberService.findMembers();
			model.addAttribute("members", members);
			
			return "members/memberList";
	}
	```
---

#### 정리

- GetMapping("주소") : (localhost:8000 + `주소`) 를 조회할때 사용, django == GET
- PostMapping("주소") : (localhost:8000 + `주소`) 를 게시할때 사용, django == POST
---

## 7/3

### 6. 스프링 DB 접근 기술
---
#### H2 데이터베이스 설치

- 설치 링크
	- https://www.h2database.com/
	- Version 2.2.224
	- Windows Installer 설치
	- 설치 위치는 spring이랑 동일한 경로

- git bash

	- /spring_selfstudy/H2/bin
		- ./h2.bat

- localhost:8082 접속
- JDBC URL 에 `jdbc:h2:~/jpashop` 입력, 연결
- 화면 뜨면 정상

- 그 다음부터는 JDBC URL 에 `jdbc:h2:tcp://localhost/~/jpashop` 입력
	- `jdbc:h2:tcp://localhost/~/test` 이거는 test로 생성했을 경우

- application.properties에 아래 내용 추가

	```txt
	spring.datasource.url=jdbc:h2:tcp://localhost/~/jpashop
	spring.datasource.driver-class-name=org.h2.Driver
	```

- 항상 @Transactional 이 있어야 한다.
- interface 가 interface를 받을 때는 extends를 쓴다.
---
---
---

# Spring 기본

## 7/4

### 2. 스프링 핵심 원리 이해1 - 예제 만들기
---

#### 스프링 설치

- 프로젝트 선택
  - Project: Gradle - Groovy Project
  - Spring Boot: 3.x.x
	- Language: Java
	- Packaging: Jar
	- Java: 17

- Project Metadata
	- groupId: hello
	- artifactId: core
	- `Dependencies: 아무것도 선택하지 않는다.`
---

#### Gradle 전체 설정

```gradle
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.3.1'
	id 'io.spring.dependency-management' version '1.1.5'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'

//java {
//	toolchain {
//		languageVersion = JavaLanguageVersion.of(17)
//	}
//}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}


repositories {
	mavenCentral()
}


dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'


	//test 롬복 사용
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'


	//Querydsl 추가
	implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
	annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"
	annotationProcessor "jakarta.annotation:jakarta.annotation-api"
	annotationProcessor "jakarta.persistence:jakarta.persistence-api"
}


tasks.named('test') {
	useJUnitPlatform()
}


clean {
	delete file('src/main/generated')
}
```
#### 스프링 부트 3.2 부터 Gradle 옵션을 선택하자

- Build and run using에 Gradle로 설정한다. (아직까지는 인텔리제이로 사용하고 있는 중)
---

#### 회원 도메인 개발

- settings/Keymap 에서 원하는 것 검색하면 해당하는 단축키를 알려준다.
- ctrl + shift + enter : 자동으로 `;` 생성
---

## 7/5

### 3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용
---

#### AppConfig 등장

- 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스를 만든다.

	```java
	package hello.core;

	import hello.core.discount.FixDiscountPolicy;
	import hello.core.member.MemberService;
	import hello.core.member.MemberServiceImpl;
	import hello.core.member.MemoryMemberRepository;
	import hello.core.order.OrderService;
	import hello.core.order.OrderServiceImpl;

	public class AppConfig {

			public MemberService memberService() {
					return new MemberServiceImpl(new MemoryMemberRepository());
			}

			public OrderService orderService() {
					return new OrderServiceImpl(
							new MemoryMemberRepository(),
							new FixDiscountPolicy());
			}

	}
	```

- 애플리케이션의 실제 동작에 필요한 구현 객체를 생성
	- MemberServiceImpl
	- MemoryMemberRepository
	- OrderServiceImpl
	- FixDiscountPolicy

- 생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.
	- MemberServiceImpl -> MemoryMemberRepository
	- OrderServiceImpl -> MemoryMemberRepository , FixDiscountPolicy
---
#### AppConfig 리팩터링

```java
package hello.core;

import hello.core.discount.DiscountPolicy;
import hello.core.discount.FixDiscountPolicy;
import hello.core.member.MemberRepository;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.member.MemoryMemberRepository;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class AppConfig {

		public MemberService memberService() {
				return new MemberServiceImpl(memberRepository());
		}

		public OrderService orderService() {
				return new OrderServiceImpl(
						memberRepository(),
						discountPolicy());
		}

		public MemberRepository memberRepository() {
				return new MemoryMemberRepository();
		}

		public DiscountPolicy discountPolicy() {
				return new FixDiscountPolicy();
		}
}
```

- new MemoryMemberRepository() 이 부분이 중복 제거되었다.
- MemoryMemberRepository 를 다른 구현체로 변경할 때 한 부분만 변경하면 된다.
- AppConfig 를 보면 역할과 구현 클래스가 한눈에 들어온다. 
- 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.
---
#### 스프링으로 전환하기

- AppConfig 스프링 기반으로 변경

	```java
	package hello.core;

	import hello.core.discount.DiscountPolicy;
	import hello.core.discount.FixDiscountPolicy;
	import hello.core.discount.RateDiscountPolicy;
	import hello.core.member.MemberService;
	import hello.core.member.MemberServiceImpl;
	import hello.core.member.MemoryMemberRepository;
	import hello.core.order.OrderService;
	import hello.core.order.OrderServiceImpl;
	import org.springframework.context.annotation.Bean;
	import org.springframework.context.annotation.Configuration;

	@Configuration
	// 항상 붙여야함
	public class AppConfig {

			@Bean
			public MemberService memberService() {

					return new MemberServiceImpl(memberRepository());
			}

			@Bean
			public OrderService orderService() {
					return new OrderServiceImpl(
									memberRepository(),
									discountPolicy());
			}

			@Bean
			public MemoryMemberRepository memberRepository() {
					return new MemoryMemberRepository();
			}

	//    public DiscountPolicy discountPolicy() {
	//        return new FixDiscountPolicy();
	//    }

			@Bean
			public DiscountPolicy discountPolicy() {
					return new RateDiscountPolicy();
			}

	}
	```

	- AppConfig에 설정을 구성한다는 뜻의 @Configuration 을 붙여준다.
	- 각 메서드에 @Bean 을 붙여준다. 스프링 컨테이너에 스프링 빈으로 등록한다.

- 이후 MemberApp, OrderApp 수정하고, 두 코드를 실행하면 스프링 관련 로그가 몇줄 실행되면서 기존과 동일한 결과가 출력된다.
---
#### 스프링 컨테이너

- ApplicationContext == 스프링 컨테이너
- 기존에는 개발자가 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해서 사용한다.
- 스프링 컨테이너는 @Configuration 이 붙은 AppConfig 를 설정(구성) 정보로 사용한다. 
- @Bean 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 스프링 빈은 @Bean 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다. ( memberService , orderService )
- 이전에는 개발자가 필요한 객체를 AppConfig 를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 
- 스프링 빈은 applicationContext.getBean() 메서드를 사용해서 찾을 수 있다.
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.
---
#### 스프링 부트 3.1 이상 - 로그 출력 안되는 문제 해결

- src/main/resources/logback.xml 에 파일 생성

```xml
<configuration>
 <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
 <encoder>
 <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} -%kvp- 
%msg%n</pattern>
 </encoder>
 </appender>
 <root level="DEBUG">
 <appender-ref ref="STDOUT" />
 </root>
</configuration>
```
---

## 7/5

### 4. 스프링 컨테이너와 스프링 빈
---

#### 스프링 컨테이너 생성

```java
//스프링 컨테이너 생성
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```

- ApplicationContext == 스프링 컨테이너, 인터페이스
---
##### 스프링 컨테이너의 생성과정

1. 스프링 컨테이너 생성 (AppConfig.class)

- new AnnotationConfigApplicationContext(AppConfig.class)
- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다

2. 스프링 빈 등록

- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.

- 빈 이름
  - 빈 이름은 메서드 이름을 사용한다.
  - 빈 이름을 직접 부여할 수 도 있다. 

- `빈 이름은 항상 다른 이름을 부여해야 한다`

3. 스프링 빈 의존관계 설정
---
#### 컨테이너에 등록된 모든 빈 조회

- 모든 빈 출력하기

	- 실행하면 스프링에 등록된 모든 빈 정보를 출력할 수 있다.
	- ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.
	- ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회한다.

- 애플리케이션 빈 출력하기
  - 스프링이 내부에서 사용하는 빈은 제외하고, 내가 등록한 빈만 출력해본다.
  - 스프링이 내부에서 사용하는 빈은 getRole() 로 구분할 수 있다.
    - ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈
    - ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈
---

#### 스프링 빈 조회 - 기본

- 스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법
  - ac.getBean(빈이름, 타입)
  - ac.getBean(타입)
  - 조회 대상 스프링 빈이 없으면 예외 발생
    - NoSuchBeanDefinitionException: No bean named 'xxxxx' available
---

#### 스프링 빈 조회 - 동일한 타입이 둘 이상

- 타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때는 빈 이름을 지정.
- ac.getBeansOfType() 을 사용하면 해당 타입의 모든 빈을 조회할 수 있다.
---

#### 스프링 빈 조회 - 상속 관계

- 부모 타입으로 조회하면, 자식 타입도 함께 조회한다.
- 그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면, 모든 스프링 빈을 조회한다.

---

#### BeanFactory와 ApplicationContext

- BeanFactory
  - 스프링 컨테이너의 최상위 인터페이스다.
  - 스프링 빈을 관리하고 조회하는 역할을 담당한다.
  - getBean() 을 제공한다.
  - 지금까지 우리가 사용했던 대부분의 기능은 BeanFactory가 제공하는 기능이다.

- ApplicationContext
  - BeanFactory 기능을 모두 상속받아서 제공한다.
  - 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 그러면 둘의 차이가 뭘까?
  - 애플리케이션을 개발할 때는 빈을 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요하다. 

- ApplicatonContext가 제공하는 부가기능

- 메시지소스를 활용한 국제화 기능
  - 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력

- 환경변수
  - 로컬, 개발, 운영등을 구분해서 처리

- 애플리케이션 이벤트
  - 이벤트를 발행하고 구독하는 모델을 편리하게 지원

- 편리한 리소스 조회
  - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

##### 정리

- ApplicationContext는 BeanFactory의 기능을 상속받는다.
- ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다.
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
- BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다.
---

## 7/7

### 5. 싱글톤 컨테이너
---

#### 웹 애플리케이션과 싱글톤

- 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때 마다 객체를 새로 생성한다.
- 고객 트래픽이 초당 100이 나오면 초당 100개 객체가 생성되고 소멸된다! -> `메모리 낭비가 심하다.`
- 해결방안은 해당 객체가 딱 1개만 생성되고, 공유하도록 설계하면 된다. -> `싱글톤 패턴`
---
#### 싱글톤 패턴

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
- 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
  - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.

- test에 생성한다

- package hello.core.singleton;

	```java
	public class SingletonService {
			//1. static 영역에 객체를 딱 1개만 생성해둔다.
			private static final SingletonService instance = new SingletonService();

			//2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한
			다.
			public static SingletonService getInstance() {
					return instance;
			}

			//3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
			private SingletonService() {
			}

			public void logic() {
					System.out.println("싱글톤 객체 로직 호출");
			}
	}
	```

1. static 영역에 객체 instance를 미리 하나 생성한다.
2. 이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다. 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.
3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.

- 싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 
- 싱글톤 패턴은 다음과 같은 수 많은 문제점들을 가지고 있다.

- 싱글톤 패턴 문제점
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP를 위반한다.
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
  - 테스트하기 어렵다.
  - 내부 속성을 변경하거나 초기화 하기 어렵다.
  - private 생성자로 자식 클래스를 만들기 어렵다.
  - 결론적으로 유연성이 떨어진다.
  - 안티패턴으로 불리기도 한다.
---
#### 싱글톤 컨테이너

- 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
  - 컨테이너는 객체를 하나만 생성해서 관리한다.

- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.

- 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
  - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
  - DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.
---

#### 싱글톤 방식의 주의점

- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.

- `무상태(stateless)로 설계해야 한다!`
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!!

- `스프링 빈은 항상 무상태(stateless)로 설계해야 한다..`

---

#### @Configuration과 바이트코드 조작의 마법

- 스프링 설정 정보는 항상 @Configuration 을 사용해야 한다.
---

## 7/7

### 6. 컴포넌트 스캔
---

#### 컴포넌트 스캔과 의존관계 자동 주입 시작하기

- 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다
- 의존관계도 자동으로 주입하는 @Autowired 라는 기능도 제공한다.

- 컴포넌트 스캔을 사용하려면 먼저 @ComponentScan 을 설정 정보에 붙여주면 된다.
- 기존의 AppConfig와는 다르게 @Bean으로 등록한 클래스가 하나도 없다!

1. @ComponentScan

	- @ComponentScan 은 @Component 가 붙은 모든 클래스를 스프링 빈으로 등록한다.
	- 이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
  	- 빈 이름 기본 전략: MemberServiceImpl 클래스 memberServiceImpl
  	- 빈 이름 직접 지정: 만약 스프링 빈의 이름을 직접 지정하고 싶으면 @Component("memberService2") 이런식으로 이름을 부여하면 된다.

2. @Autowired 의존관계 자동 주입

   - 생성자에 @Autowired 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
   - 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.
     - getBean(MemberRepository.class) 와 동일하다고 이해하면 된다.
---

#### 탐색 위치와 기본 스캔 대상

##### 탐색할 패키지의 시작 위치 지정

- 탐색할 패키지의 시작 위치 지정
	```java
	@ComponentScan(
			basePackages = "hello.core",
	}
	```

- basePackages : 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
  - basePackages = {"hello.core", "hello.service"} 이렇게 여러 시작 위치를 지정할 수도 있다.
- basePackageClasses : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.
- 만약 지정하지 않으면 @ComponentScan 이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.

---

#### 컴포넌트 스캔 기본 대상

- @Component : 
  - 컴포넌트 스캔에서 사용

- @Controller : 
  - 스프링 MVC 컨트롤러에서 사용
  - 스프링 MVC 컨트롤러로 인식

- @Service : 
  - 스프링 비즈니스 로직에서 사용
  - 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다.

- @Repository : 
  - 스프링 데이터 접근 계층에서 사용
  - 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다 

- @Configuration : 
  - 스프링 설정 정보에서 사용
  - 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.

---

#### 필터

- includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
- excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.

---

#### FilterType 옵션

- ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.
  - ex) org.example.SomeAnnotation

- ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
  - ex) org.example.SomeClass

- ASPECTJ: AspectJ 패턴 사용
  - ex) org.example..*Service+

- REGEX: 정규 표현식
  - ex) org\.example\.Default.*

- CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
  - ex) org.example.MyTypeFilter

---

#### 중복 등록과 충돌
- resources/application.properties
  - `spring.main.allow-bean-definition-overriding=false` 추가
---

