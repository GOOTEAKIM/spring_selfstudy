# Spring 입문

## 6/29

### 커피잔 아이콘이 뜨면서 코드 실행이 안될 때?

- src 우클릭 - Make Directory as - Source Root
---
### 1. 프로젝트 환경 설정
---
#### 프로젝트 생성

- 스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성
- https://start.spring.io/

- 프로젝트 선택
  - Project: Gradle - Groovy Project
  - Spring Boot: 3.x.x
  - Language: Java
  - Packaging: Jar
  - Java: 17 또는 21

- Project Metadata
  - groupId: hello
  - artifactId: hello-spring

- Dependencies: Spring Web, Thymeleaf

- 스프링 부트 3.0 이상을 선택 할 것
---
#### Gradle 전체 설정

```gradle
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.3.1'
	id 'io.spring.dependency-management' version '1.1.5'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}


//java {
//	toolchain {
//		languageVersion = JavaLanguageVersion.of(22)
//	}
//}

repositories {
	mavenCentral()
}


dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'


	//test 롬복 사용
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'


	//Querydsl 추가
	implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
	annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"
	annotationProcessor "jakarta.annotation:jakarta.annotation-api"
	annotationProcessor "jakarta.persistence:jakarta.persistence-api"
}


tasks.named('test') {
	useJUnitPlatform()
}


clean {
	delete file('src/main/generated')
}

```

- 동작 확인
  - 기본 메인 클래스 실행
  - 스프링 부트 메인 실행 후 에러페이지로 간단하게 동작 확인( http://localhost:8080 )
---
#### View 환경설정

- src/main/resources/static/index.html

	```html
	<!DOCTYPE HTML>
	<html>
	<head>
	<title>Hello</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	</head>
	<body>
	Hello
	<a href="/hello">hello</a>
	</body>
	</html>
	```

- src/main/resources/templates/hello.html

	```html
	<!DOCTYPE HTML>
	<html xmlns:th="http://www.thymeleaf.org">
	<head>
			<title>Hello</title>
			<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	</head>
	<body>
	<p th:text="'안녕하세요. ' + ${data}" >안녕하세요. 손님</p>
	</body>
	</html>
	```

- src/main/main/java/hello.hello_spring/controller/HelloController

	```java
	package hello.hello_spring.controller;

	import org.springframework.stereotype.Controller;
	import org.springframework.ui.Model;
	import org.springframework.web.bind.annotation.GetMapping;

	@Controller
	public class HelloController {
			@GetMapping("hello")
			public String hello(Model model) {
					model.addAttribute("data", "hello!");
					return "hello";
			}
	}
	```

- 서버 실행
- http://localhost:8080/ 에서 글자가 나오는지 확인
- http://localhost:8080/hello 에서 글자가 나오는지 확인
- 설정 완료
---
### 빌드

- 빌드를 바로 하면 일단 JAVA_HOME 이 없다고 나온다

1. 윈도우에서 `시스템 변수 환경 편집` 실행.
2. 환경변수
3. 사용자 변수 새로 만들기
	- 변수 이름 : JAVA_HOME
	- 변수 값 : C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2024.1.2\jbr
4. 시스템 변수
	- 변수 새로 만들기
	- 변수 이름 : JAVA_HOME
	- 변수 값 : C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2024.
	
	- Path 편집
  	- 새로 만들기 : %JAVA_HOME%\bin
5. ./gradlew build 
6. 빌드 완료

---

## 7/1

### 2. 스프링 웹 개발 기초
---
#### Thymeleaf 가 작동 안할때

1. src/main/resources/application.properties 파일 확인

	```properties
	spring.thymeleaf.prefix=classpath:/templates/
	spring.thymeleaf.suffix=.html
	spring.thymeleaf.enabled=true
	```
2. 해당 코드 추가
3. 빌드 실행 (`./gradlew build`)
---

#### MVC 와 템플릿 엔진

- Controller

	```java
	@Controller
	public class HelloController {
			@GetMapping("hello-mvc")
			public String helloMvc(@RequestParam("name") String name, Model model) {
					model.addAttribute("name", name);
					return "hello-template";
			}
	}
	```

- View (resources/templates/hello-template.html)

```html
<html xmlns:th="http://www.thymeleaf.org">
<body>
<p th:text="'hello ' + ${name}">hello! empty</p>
</body>
</html>
```

- 실행
  - http://localhost:8080/hello-mvc?name=spring
---
### API

- @ResponseBody 문자 반환

	```java
	@Controller
	public class HelloController {

			@GetMapping("hello-string")
			@ResponseBody
			
			public String helloString(@RequestParam("name") String name) {
					return "hello " + name;
			}
	}
	```

	- `@ResponseBody` 를 사용하면 뷰 리졸버( viewResolver )를 사용하지 않음
	- 대신에 HTTP의 BODY에 문자 내용을 직접 반환

- 실행
  - http://localhost:8080/hello-string?name=spring

---

- @ResponseBody 객체 반환

```java
@Controller
public class HelloController {
		@GetMapping("hello-api")
		@ResponseBody

		public Hello helloApi(@RequestParam("name") String name) {
				Hello hello = new Hello();
				hello.setName(name);
				return hello;
		}

		static class Hello {
				private String name;
				public String getName() {
						return name;
				}

				public void setName(String name) {
						this.name = name;
				}
		}
}
```

- @ResponseBody 를 사용하고, 객체를 반환하면 객체가 `JSON`으로 변환됨

- 실행
	- http://localhost:8080/hello-api?name=spring
---
## 7/2

### 3. 회원 관리 예제
---
#### 회원 도메인과 리포지토리 만들기

	```java
	private Long id;
	private String name;
	```
	- alt + insert -> getter and setter

	- 테스트를 한번하면 깨끗하게 해줘야한다.
---
#### 회원 리포지토리 테스트 케이스 작성

- test/java/hello.hello_spring/폴더명

- 이 경로로 테스트 package 생성
- 클래스 이름 = 테스트 할 클래스 + Test
	- ex. MemoryMemberRepository + Test = `MemoryMemberRepositoryTest`
- public 으로 안만들어도 된다.
- 메서드 사용 전에 `@Test` 작성해줘야 한다.

- Assertions (org.junit.jupiter.api) 사용해야 한다.

- @AfterEach : 각 테스트가 종료될 때 마다 이 기능을 실행한다.
  - 테스트는 각각 독립적으로 실행되어야 한다. 
  - 테스트 순서에 의존관계가 있는 것은 좋은 테스트가 아니다.

- alt + enter -> replace static import : static import 추출
- shift + F6 : rename 
---

#### 회원 서비스 개발

- alt + insert : constructor 생성
- ctrl + alt + l : 코드 정리
- ctrl + alt + shift + t -> extract method
- ctrl + alt + v : 리턴을 해주는 대상 생성
- ctrl + alt + shift + t : 여러가지 단축어 보여줌
  - extract method : 새로운 메서드로 만들 수 있다

---

#### 회원 서비스 테스트

- ctrl + shift + T : 테스트 자동으로 생성
- 테스트 명은 한글로 바꿔도 상관없다.
---

## 7/3

### 4. 스프링 빈과 의존관계
---
#### 컴포넌트 스캔과 자동 의존관계 설정

- DI : 의존성 주입
  - 생성자에 `@Autowired` 가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아 넣어준다.


- 컴포넌트 스캔 원리
	- `@Component` 애노테이션이 있으면 스프링 빈으로 자동 등록된다.
	- `@Controller` 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문이다.

- @Autowired
  - 생성자에 @Autowired 를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입한다. 
	- 생성자가 1개만 있으면 @Autowired 는 생략할 수 있다.

- `@Component` 를 포함하는 다음 애노테이션도 스프링 빈으로 자동 등록된다.
  - @Controller
  - @Service
  - @Repository
---

## 7/3

### 5. 회원 관리 예제 - 웹 MVC 개발
---
#### 회원 웹 기능 - 홈 화면 추가

- 홈 컨트롤러 추가

	```java
	package hello.hellospring.controller;
	import org.springframework.stereotype.Controller;
	import org.springframework.web.bind.annotation.GetMapping;

	@Controller
	public class HomeController {

			@GetMapping("/")
			public String home() {
					return "home";
			}
	}
	```

	- GetMapping("주소") : (localhost:8000 + `주소`) 를 조회할때 사용, django == GET
---
#### 회원 웹 기능 - 등록

- 회원 등록 폼 컨트롤러

	```java
	@Controller
	public class MemberController {
			private final MemberService memberService;

			@Autowired
			public MemberController(MemberService memberService) {
					this.memberService = memberService;
			}

			@GetMapping(value = "/members/new")
			public String createForm() {
					return "members/createMemberForm";
			}
	}
	```
---
- 회원 등록 컨트롤러

  - 웹 등록 화면에서 데이터를 전달 받을 폼 객체

  	```java
  	public class MemberForm {
  			private String name;

  			public String getName() {
  					return name;
  			}

  			public void setName(String name) {
  					this.name = name;
  			}
  	}
  	```

  - 회원 컨트롤러에서 회원을 실제 등록하는 기능.

	```java
	@PostMapping(value = "/members/new")
	public String create(MemberForm form) {

			Member member = new Member();
			member.setName(form.getName());

			memberService.join(member);

			return "redirect:/";
	}
	```

  - PostMapping("주소") : (localhost:8000 + `주소`) 를 게시할때 사용, django == POST
---
#### 회원 웹 기능 - 조회

- 회원 컨트롤러에서 조회 기능

	```java
	@GetMapping(value = "/members")
	public String list(Model model) {

			List<Member> members = memberService.findMembers();
			model.addAttribute("members", members);
			
			return "members/memberList";
	}
	```
---

#### 정리

- GetMapping("주소") : (localhost:8000 + `주소`) 를 조회할때 사용, django == GET
- PostMapping("주소") : (localhost:8000 + `주소`) 를 게시할때 사용, django == POST
---

## 7/3

### 6. 스프링 DB 접근 기술
---
#### H2 데이터베이스 설치

- 설치 링크
	- https://www.h2database.com/
	- Version 2.2.224
	- Windows Installer 설치
	- 설치 위치는 spring이랑 동일한 경로

- git bash

	- /spring_selfstudy/H2/bin
		- ./h2.bat

- localhost:8082 접속
- JDBC URL 에 `jdbc:h2:~/jpashop` 입력, 연결
- 화면 뜨면 정상

- 그 다음부터는 JDBC URL 에 `jdbc:h2:tcp://localhost/~/jpashop` 입력
	- `jdbc:h2:tcp://localhost/~/test` 이거는 test로 생성했을 경우

- application.properties에 아래 내용 추가

	```txt
	spring.datasource.url=jdbc:h2:tcp://localhost/~/jpashop
	spring.datasource.driver-class-name=org.h2.Driver
	```

- 항상 @Transactional 이 있어야 한다.
- interface 가 interface를 받을 때는 extends를 쓴다.
---
---
---

# Spring 기본

## 7/4

### 2. 스프링 핵심 원리 이해1 - 예제 만들기
---

#### 스프링 설치

- 프로젝트 선택
  - Project: Gradle - Groovy Project
  - Spring Boot: 3.x.x
	- Language: Java
	- Packaging: Jar
	- Java: 17

- Project Metadata
	- groupId: hello
	- artifactId: core
	- `Dependencies: 아무것도 선택하지 않는다.`
---

#### Gradle 전체 설정

```gradle
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.3.1'
	id 'io.spring.dependency-management' version '1.1.5'
}

group = 'hello'
version = '0.0.1-SNAPSHOT'

//java {
//	toolchain {
//		languageVersion = JavaLanguageVersion.of(17)
//	}
//}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}


repositories {
	mavenCentral()
}


dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0'
	compileOnly 'org.projectlombok:lombok'
	runtimeOnly 'com.h2database:h2'
	annotationProcessor 'org.projectlombok:lombok'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'


	//test 롬복 사용
	testCompileOnly 'org.projectlombok:lombok'
	testAnnotationProcessor 'org.projectlombok:lombok'


	//Querydsl 추가
	implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
	annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"
	annotationProcessor "jakarta.annotation:jakarta.annotation-api"
	annotationProcessor "jakarta.persistence:jakarta.persistence-api"
}


tasks.named('test') {
	useJUnitPlatform()
}


clean {
	delete file('src/main/generated')
}
```
#### 스프링 부트 3.2 부터 Gradle 옵션을 선택하자

- Build and run using에 Gradle로 설정한다. (아직까지는 인텔리제이로 사용하고 있는 중)
---

#### 회원 도메인 개발

- settings/Keymap 에서 원하는 것 검색하면 해당하는 단축키를 알려준다.
- ctrl + shift + enter : 자동으로 `;` 생성
---

## 7/5

### 3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용
---

#### AppConfig 등장

- 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스를 만든다.

	```java
	package hello.core;

	import hello.core.discount.FixDiscountPolicy;
	import hello.core.member.MemberService;
	import hello.core.member.MemberServiceImpl;
	import hello.core.member.MemoryMemberRepository;
	import hello.core.order.OrderService;
	import hello.core.order.OrderServiceImpl;

	public class AppConfig {

			public MemberService memberService() {
					return new MemberServiceImpl(new MemoryMemberRepository());
			}

			public OrderService orderService() {
					return new OrderServiceImpl(
							new MemoryMemberRepository(),
							new FixDiscountPolicy());
			}

	}
	```

- 애플리케이션의 실제 동작에 필요한 구현 객체를 생성
	- MemberServiceImpl
	- MemoryMemberRepository
	- OrderServiceImpl
	- FixDiscountPolicy

- 생성한 객체 인스턴스의 참조(레퍼런스)를 생성자를 통해서 주입(연결)해준다.
	- MemberServiceImpl -> MemoryMemberRepository
	- OrderServiceImpl -> MemoryMemberRepository , FixDiscountPolicy

#### AppConfig 리팩터링

```java
package hello.core;

import hello.core.discount.DiscountPolicy;
import hello.core.discount.FixDiscountPolicy;
import hello.core.member.MemberRepository;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.member.MemoryMemberRepository;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class AppConfig {

		public MemberService memberService() {
				return new MemberServiceImpl(memberRepository());
		}

		public OrderService orderService() {
				return new OrderServiceImpl(
						memberRepository(),
						discountPolicy());
		}

		public MemberRepository memberRepository() {
				return new MemoryMemberRepository();
		}

		public DiscountPolicy discountPolicy() {
				return new FixDiscountPolicy();
		}
}
```

- new MemoryMemberRepository() 이 부분이 중복 제거되었다.
- MemoryMemberRepository 를 다른 구현체로 변경할 때 한 부분만 변경하면 된다.
- AppConfig 를 보면 역할과 구현 클래스가 한눈에 들어온다. 
- 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있다.

#### 스프링으로 전환하기

- AppConfig 스프링 기반으로 변경

	```java
	package hello.core;

	import hello.core.discount.DiscountPolicy;
	import hello.core.discount.FixDiscountPolicy;
	import hello.core.discount.RateDiscountPolicy;
	import hello.core.member.MemberService;
	import hello.core.member.MemberServiceImpl;
	import hello.core.member.MemoryMemberRepository;
	import hello.core.order.OrderService;
	import hello.core.order.OrderServiceImpl;
	import org.springframework.context.annotation.Bean;
	import org.springframework.context.annotation.Configuration;

	@Configuration
	// 항상 붙여야함
	public class AppConfig {

			@Bean
			public MemberService memberService() {

					return new MemberServiceImpl(memberRepository());
			}

			@Bean
			public OrderService orderService() {
					return new OrderServiceImpl(
									memberRepository(),
									discountPolicy());
			}

			@Bean
			public MemoryMemberRepository memberRepository() {
					return new MemoryMemberRepository();
			}

	//    public DiscountPolicy discountPolicy() {
	//        return new FixDiscountPolicy();
	//    }

			@Bean
			public DiscountPolicy discountPolicy() {
					return new RateDiscountPolicy();
			}

	}
	```

	- AppConfig에 설정을 구성한다는 뜻의 @Configuration 을 붙여준다.
	- 각 메서드에 @Bean 을 붙여준다. 스프링 컨테이너에 스프링 빈으로 등록한다.

- 이후 MemberApp, OrderApp 수정하고, 두 코드를 실행하면 스프링 관련 로그가 몇줄 실행되면서 기존과 동일한 결과가 출력된다.

#### 스프링 컨테이너

- ApplicationContext == 스프링 컨테이너
- 기존에는 개발자가 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해서 사용한다.
- 스프링 컨테이너는 @Configuration 이 붙은 AppConfig 를 설정(구성) 정보로 사용한다. 
- @Bean 이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.
- 스프링 빈은 @Bean 이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다. ( memberService , orderService )
- 이전에는 개발자가 필요한 객체를 AppConfig 를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 
- 스프링 빈은 applicationContext.getBean() 메서드를 사용해서 찾을 수 있다.
- 기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.

#### 스프링 부트 3.1 이상 - 로그 출력 안되는 문제 해결

- src/main/resources/logback.xml 에 파일 생성

```xml
<configuration>
 <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
 <encoder>
 <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} -%kvp- 
%msg%n</pattern>
 </encoder>
 </appender>
 <root level="DEBUG">
 <appender-ref ref="STDOUT" />
 </root>
</configuration>
```
